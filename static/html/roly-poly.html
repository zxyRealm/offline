<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
  <script src="../three/three.min.js"></script>
  <script src="../three/OrbitControls.js"></script>
</head>
<body>
  <div id="WebGL-output"></div>
  <script>
    let scene, camera, renderer
    let pointLight
    let shapeOne, shapeTwo
    function init() {
      // 第一步：
      // 创建一个场景 - 场景中包含我们想要渲染的所有对象。
      // 这是放置物体，灯光和相机的地方。
      scene = new THREE.Scene()
      // 第二步：添加相机
      // 常用的相机有透视相机和正交相机。
      // 参数：视野，纵横比，最近视距，最远视距
      camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000)
      camera.position.set(200,200,0);
      camera.lookAt(new THREE.Vector3(0,0,0))
      // 第三步：添加渲染器
      // 渲染器负责从给定摄像机角度去渲染场景。
      renderer = new THREE.WebGLRenderer({ antialias: true })
      renderer.setSize(window.innerWidth, window.innerHeight)
      renderer.setClearColor(0xeeeeee)
      // document.getElementById('WebGL-output').appendChild(renderer.domElement)
      // renderer.render(scene, camera)

      // 构建一个平面模型
      createPlane()

      // 构建一个orbit控制器
      createOrbit()

      // 构建一个多边形并着色
      createOctahedron()
      createOctahedron2()

      // 制造光源
      createLight()

      // 阴影
      castShadows()

      // 投射 - 接收阴影
      renderer.shadowMap.enabled = true
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      document.getElementById('WebGL-output').appendChild(renderer.domElement)
      renderer.render(scene, camera)
    }

    // 创建一个平面
    function createPlane() {
      // Geometry: 描述几何体的形状
      let planeGeo = new THREE.PlaneGeometry(100, 100, 5, 5)
      // Material：描述几何体的外观
      let planeMat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide})
      // Mesh: 几何体的形状和材质组成网格，然后它就可以在场景中自由移动了
      let planeMesh = new THREE.Mesh(planeGeo, planeMat)
      planeMesh.rotateX(Math.PI/2)
      scene.add(planeMesh)
    }

    // 创建一个Orbit控制器
    // 允许捕获鼠标事件，从而重新再场景里定位相机
    function createOrbit(){
      let controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.addEventListener('change', function(){
        renderer.render(scene, camera)
      })
    }

    // 创建一个几何体
    function createOctahedron(){
      let geometry = new THREE.OctahedronGeometry(10, 1)
      let material = new THREE.MeshStandardMaterial({
        color: 0xff0051,
        flatShading: THREE.FlatShading,
        metallness: 0,
        roughness: 1
      })
      shapeOne = new THREE.Mesh(geometry, material)
      shapeOne.position.y = 10
      shapeOne.castShadow = true;
      scene.add(shapeOne)
    }

    function createOctahedron2() {
      let shapeTwo = new THREE.Mesh(
        new THREE.OctahedronGeometry(5, 1),
        new THREE.MeshStandardMaterial({
          color: 0x47689b,
          flatShading: THREE.FlatShading ,
          metalness: 0,
          roughness: 0.8
        })
      );
      shapeTwo.position.y += 5;
      shapeTwo.position.x += 15;
      shapeTwo.rotateZ(Math.PI/5);
      shapeTwo.castShadow = true;
      scene.add(shapeTwo);
    }

    function createLight() {
      pointLight = new THREE.PointLight( 0xffffff, 1 );
      pointLight.position.set( 25, 50, 25 );
      scene.add(pointLight);
    }

    function castShadows() {
      // 第一步 在渲染器上启用阴影
      renderer.shadowMap.enable = true
      renderer.shadowMap.type = THREE.PCFShadowMap
      // 第二步 指定应该投射阴影的灯光，以及要渲染的阴影贴图大小
      pointLight.castShadow = true
      pointLight.shadow.mapSize.width = 1024
      pointLight.shadow.mapSize.height = 1024
      // 第三步 最后指定哪些网格应该接收阴影
      createShadowsMesh()
    }

    function createShadowsMesh() {
      let shadowMaterial = new THREE.ShadowMaterial( { color: '#8c8c8c' } );
      shadowMaterial.opacity = 0.5;
      let groundMesh = new THREE.Mesh(
        new THREE.BoxGeometry( 100, .1, 100 ),
        shadowMaterial
      );
      groundMesh.receiveShadow = true;
      scene.add( groundMesh );
    }

    // 定义一个装饰，它只是一个定制化的THREE.GROUP
    let Decoration = function() {
      THREE.Group.apply(this, arguments)
      let color = ['#ff0051', '#f56762','#a53c6c','#f19fa0','#72bdbf','#47689b']
      let bauble = new THREE.Mesh(
        addNoise(new THREE.OctahedronGeometry(12,1), 2),
        new THREE.MeshStandardMaterial({
          color: colors[Math.floor(Math.random()*colors.length)],
          shading: THREE.FlatShading,
          matalness: 0,
          roughness: 0.8,
          refractionRatio: 0.25
        })
      )
      bauble.castShadow = true
      bauble.receiveShadow = true
      bauble.rotateZ(Math.random() * Math.PI * 2)
      bauble.rotateY(Math.random() * Math.PI * 2)
      this.add(bauble)

      let shapeOne = new THREE.Mesh(
        addNoise(new THREE.CylinderGeometry(4, 6, 10, 6, 1), 0.5),
        new THREE.MeshStandardMaterial({
          color: 0xf8db08,
          shading: THREE.FlatShading,
          metallness: 0,
          roughness: 0.8,
          refractionRatio: 0.25
        })
      )
      shapeOne.position.y += 8
      shapeOne.castShadow = true
      shapeOne.receiveShadow = true
      this.add(shapeOne)

      let shapeTwo = new THREE.Mesh(
        addNoise(new THREE.ToruGeometry(2, 1, 6, 4, Math.PI), 0.2),
        new THREE.MeshStandardMaterial({
          color: 0xf8db08,
          shading: THREE.FlatShading,
          metalness: 0,
          roughness: 0.8,
          refractionRatio: 0.25
        })
      )
      shapeTwo.position.y += 13
      shapeTwo.castShadow = true
      shapeTwo.receiveShadow = true
      this.add(shapeTwo)
    }

    Decoration.prototype = Object.create(THREE.Group.prototype)
    Decoration.prototype.constructor = Decoration

    function addNoise(geometry, noiseX, noiseY, noiseZ) {
      noiseX = noiseX || 2;
      noiseY = noiseY || noiseX;
      noiseZ = noiseZ || noiseY;
      for(let i=0; i<geometry.vertices.length; i++) {
        let v = geometry.vertices[i];
        v.x += -noiseX/2 + Math.random() * noiseX;
        v.y += -noiseY/2 + Math.random() * noiseY;
        v.z += -noiseZ/2 + Math.random() * noiseZ;
      }
      return geometry;
    }

    init()
  </script>
</body>
</html>
