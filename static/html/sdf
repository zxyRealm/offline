
  // methods: {
  //   init () {
  //     this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true })
  //     this.renderer.setSize(window.innerWidth, window.innerHeight)
  //     this.renderer.setClearColor('#ffffff', 1.0)
  //     this.scene = new THREE.Scene()
  //     this.scene.background = new THREE.Color('#000000')
  //     this.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000)
  //     this.camera.position.set(150, 140, 230) // 相机位置及角度
  //     this.scene.add(this.camera)
  //
  //     let light = new THREE.PointLight('#ffffff', 0.8)
  //     this.camera.add(light)
  //
  //     // 添加辅助坐标
  //     let axesHelper = new THREE.AxesHelper(10)
  //     this.scene.add(axesHelper)
  //
  //     // 添加控制器
  //     this.addControl()
  //
  //     // 分组的中心点需要重置到图片中心点的位置
  //     this.group = new THREE.Group()
  //     this.group.position.set(-290 * this.scale, 0, -241 * this.scale)
  //     this.scene.add(this.group)
  //
  //     // 创建楼层图片
  //     this.loadSvg(60)
  //     this.loadSvg(30)
  //     this.loadSvg(0)
  //
  //     let count = 0
  //     setInterval(() => {
  //       this.createPointCloud(count)
  //       count++
  //     }, 100)
  //
  //     let rectPath = new THREE.Path()
  //     this.path = rectPath
  //     this.createPath(rectPath)
  //
  //     document.getElementById('WebGL-output').appendChild(this.renderer.domElement)
  //     window.addEventListener('resize', this.onWindowResize, false)
  //     window.addEventListener('mousemove', this.onDocumentMouseMove, false)
  //   },
  //   loadSvg (positionY) {
  //     let svgLoader = new THREE.SVGLoader()
  //     svgLoader.load('/static/floor/floorF1.svg', (paths) => {
  //       for (let i = 0; i < paths.length; i++) {
  //         let path = paths[i]
  //         let shapes = path.toShapes(true)
  //         for (let j = 0; j < shapes.length; j++) {
  //           let shape = shapes[j]
  //           if (i === 0) {
  //             this.addShape(shape, 0x8080f0, positionY)
  //           }
  //           this.addLineShape(shape, 0x8080f0, positionY)
  //         }
  //       }
  //     })
  //   },
  //   addShape (shape, color, y) {
  //     let mesh = new THREE.Mesh(new THREE.ShapeBufferGeometry(shape), new THREE.MeshBasicMaterial({ color: color, side: THREE.DoubleSide, transparent: true, opacity: 0.1 }));
  //     mesh.position.set(0, y, 0)
  //     mesh.rotation.set(0.5 * Math.PI, 0, 0)
  //     mesh.scale.set(this.scale, this.scale, this.scale)
  //     this.planeList.push(mesh)
  //     this.group.add(mesh)
  //   },
  //   addLineShape (shape, color, y) {
  //     shape.autoClose = true
  //     let points = shape.getPoints()
  //     let line = new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), new THREE.LineBasicMaterial({ color: color }))
  //     line.position.set(0, y, 0)
  //     line.rotation.set(0.5 * Math.PI, 0, 0)
  //     line.scale.set(this.scale, this.scale, this.scale)
  //     this.lineList.push(line)
  //     this.group.add(line)
  //   },
  //   // 创建闪光粒子canvas
  //   generateSprite () {
  //     let canvas = document.createElement('canvas')
  //     canvas.width = 16
  //     canvas.height = 16
  //
  //     let context = canvas.getContext('2d')
  //     let gradient = context.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2)
  //     gradient.addColorStop(0, 'rgba(255,255,255,1)')
  //     gradient.addColorStop(0.2, 'rgba(255,255,255,1)')
  //     gradient.addColorStop(0.4, 'rgba(157,159,13,1)')
  //     gradient.addColorStop(0.7, 'rgba(0,0,0,1)')
  //
  //     context.fillStyle = gradient
  //     context.fillRect(0, 0, canvas.width, canvas.height)
  //     let texture = new THREE.Texture(canvas)
  //     texture.needsUpdate = true
  //     return texture
  //   },
  //   // 创建闪光粒子
  //   createPointCloud (i) {
  //     let floorArr = [25, 45, 65]
  //     if (i < 100) {
  //       this.pointArr[i] = new THREE.Mesh(new THREE.CircleGeometry(4, 50, 32), new THREE.MeshBasicMaterial({
  //         color: new THREE.Color('#fcff15'),
  //         transparent: true,
  //         side: THREE.DoubleSide,
  //         blending: THREE.AdditiveBlending,
  //         map: this.generateSprite()
  //       }))
  //       this.pointArr[i].sortParticles = true
  //       this.pointArr[i].position.x = this.getRandom(-100, 100)
  //       this.pointArr[i].position.y = floorArr[this.getRandom(0, 2)]
  //       this.pointArr[i].position.z = this.getRandom(-30, 30)
  //       this.pointArr[i].rotation.x = 0.5 * Math.PI
  //       this.scene.add(this.pointArr[i])
  //       this.createAnimate(this.pointArr[i], i)
  //     } else {
  //       i = i % 100
  //       this.pointArr[i].position.x = this.getRandom(-100, 100)
  //       this.pointArr[i].position.y = floorArr[this.getRandom(0, 2)]
  //       this.pointArr[i].position.z = this.getRandom(-30, 30)
  //       this.pointArr[i].rotation.x = 0.5 * Math.PI
  //       this.createAnimate(this.pointArr[i], i)
  //     }
  //   },
  //   createAnimate (knot, i) {
  //     let scaleKF = new THREE.VectorKeyframeTrack('.scale', [ 0, 0.15, 0.3, 0.5 ], [ 0, 0, 0, 1.4, 1.4, 1.4, 1, 1, 1, 0, 0, 0 ])
  //     let opacityKF = new THREE.NumberKeyframeTrack('.material.opacity', [ 0, 0.15, 0.3, 0.5 ], [ 0.3, 0.4, 1, 0 ])
  //     let clip = new THREE.AnimationClip('Action', 0.5, [ scaleKF, opacityKF ])
  //     let mixer = new THREE.AnimationMixer(knot)
  //     let clipAction = mixer.clipAction(clip)
  //     this.mixArr[i] = mixer
  //     clipAction.play()
  //     clipAction.loop = THREE.LoopOnce
  //   },
  //   /****************
  //    ***** 轨迹 ******
  //    ****************/
  //   createPath (ctx) {
  //     ctx.moveTo(0, 40)
  //     ctx.bezierCurveTo(25, 25, 20, 0, 10, 0 )
  //     ctx.bezierCurveTo(30, 0, 30, 35, 30, 35)
  //     ctx.bezierCurveTo(30, 55, 10, 77, 15, 95)
  //     ctx.lineTo(-40, 120)
  //   },
  //   getRandom (n, m) {
  //     let n1 = Number(n) // 强制转换成数字
  //     let m2 = Number(m)
  //     if (isNaN(n1) || isNaN(m2)) { // 判断是否为有效数字 ，其中一个不是有效数字就返回[0,1)之间的随机小数
  //       return Math.random()
  //     }
  //     if (n1 > m2) { // 如果n>m则交换
  //       let temp = n1
  //       n1 = m2
  //       m2 = temp
  //     }
  //     return Math.round(Math.random() * (m2 - n1) + n1)
  //   },
  //   // 添加Orbit控制器
  //   addControl () {
  //     this.controls = new THREE.OrbitControls(this.camera)
  //     this.controls.dampingFactor = 0.25
  //     this.controls.enableZoom = false
  //     this.controls.enableRotate = false
  //     this.controls.screenSpacePanning = true
  //   },
  //   onWindowResize () {
  //     this.camera.aspect = window.innerWidth / window.innerHeight
  //     this.camera.updateProjectionMatrix()
  //     this.renderer.setSize(window.innerWidth, window.innerHeight)
  //   },
  //   onDocumentMouseMove (event) {
  //     // let vector = new THREE.Vector3((event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1, 0.5)
  //     // vector = vector.unproject(this.camera)
  //     // let raycaster = new THREE.Raycaster(this.camera.position, vector.sub(this.camera.position).normalize())
  //     // let intersects = raycaster.intersectObjects(this.planeList)
  //   },
  //   render () {
  //     requestAnimationFrame(this.render)
  //     let delta = this.clock.getDelta()
  //     for (let i = 0; i < this.mixArr.length; i++) {
  //       this.mixArr[i].update(delta)
  //     }
  //     this.renderer.render(this.scene, this.camera)
  //   }
  // },
  // mounted () {
  //   this.clock = new THREE.Clock()
  //   this.init()
  //   this.render()
  // }
