<!DOCTYPE html>
<html lang="en">
<head>
  <title>draw line</title>
  <meta charset="utf-8">
  <style>
    body {
      margin: 0px;
    }
  </style>
  <script src="../three/three.min.js"></script>
</head>
<body>
<div id="WebGL-output"></div>

<script>
  let camera, scene, renderer;
  let targetRotation = 0;
  let windowHalfX = window.innerWidth / 2;
  let windowHalfY = window.innerHeight / 2;

  init();
  animate();

  var t = 0.0; // 路径遍历点
  var s = 0.0005; // 移动速度
  var arrows; // 每个小格子
  var path; // 目标路径导线

  function init() {
    // 创建相机
    camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );
    camera.position.set( 150, 140, 530 );
    // 创建场景
    scene = new THREE.Scene();
    // 创建路径点集合对象
    parent = new THREE.Object3D();
    parent.position.y = 0;
    scene.add( parent );

    // 路径点
    arrows = [];
    arrowsLength = 40; // 路径点数量
    for(let i = 0 ; i < arrowsLength; i++){
      arrows[i] = new THREE.Mesh(
        new THREE.CubeGeometry(3, 1, 1), // 定义路径点的长宽高
        new THREE.MeshBasicMaterial({color: '#E13640'}) // 定义颜色
      );
      arrows[i].rotation.set(0.5*Math.PI, 0, 0);
      parent.add(arrows[i]);  // 加入到路径集合里
    }

    // 生成路径并填充路径
    let rectPath = new THREE.Path();
    function roundedPath(ctx){
      ctx.moveTo( 0, 40 );
      ctx.bezierCurveTo( 25, 25, 20, 0, 10, 0 );
      ctx.bezierCurveTo( 30, 0, 30, 35, 30, 35 );
      ctx.bezierCurveTo( 30, 55, 10, 77, 15, 95 );
      ctx.lineTo(-40, 120)
    }
    path = rectPath;
    roundedPath(rectPath);
    renderer = new THREE.WebGLRenderer();
    renderer.setSize( window.innerWidth, window.innerHeight );
    document.getElementById("WebGL-output").appendChild(renderer.domElement);
    window.addEventListener( 'resize', onWindowResize, false );
  }

  let points = [
    new THREE.Vector3(0, 40, 3),
    new THREE.Vector3(10, 0, 3),
    new THREE.Vector3(30, 35, 3),
    new THREE.Vector3(15, 95, 3),
    new THREE.Vector3(-40, 120, 3)
  ];

  function createCircle (vector) {
    let geom = new THREE.CircleGeometry(2, 50)
    let material = new THREE.MeshBasicMaterial({
      color: '#E16568'
    })
    let cloud = new THREE.Mesh(geom, material);
    cloud.position.set(vector.x, vector.y, vector.z)
    scene.add(cloud)
  }

  for (let i=0; i< points.length; i++){
    createCircle(points[i])
  }

  function onWindowResize() {
    windowHalfX = window.innerWidth / 2;
    windowHalfY = window.innerHeight / 2;
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize( window.innerWidth, window.innerHeight );
  }

  function animate() {
    requestAnimationFrame( animate );
    render();
  }

  function render() {
    t = (t + s) % 1.0; // 增量t同时保持在0.0和1.0之间
    for(let i = 0 ; i < arrowsLength; i++){ // 遍历所有box
      let ti = ((i / arrowsLength) + t) % 1.0; // 计算遍历路径，包括路径上每个框自身的偏移量
      let p = path.getPoint(ti); // 点在t上
      let pn = path.getPoint((ti+s)%1.0); // 点在下一个t的迭代点
      if(p != null && pn != null){
        // 移动到当前位置
        arrows[i].position.x = p.x;
        arrows[i].position.y = p.y;
        // 基于下一个位置获得定位
        arrows[i].rotation.z = Math.atan2(pn.y-p.y,pn.x-p.x);
      }
    }
    parent.rotation.y += ( targetRotation - parent.rotation.y ) * 0.05;
    renderer.render( scene, camera );

  }
</script>

</body>
</html>
