<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <style>
    html,
    body {
      margin: 0px;
      padding: 0px
    }

  </style>
  <script src="/static/three/three.min.js"></script>
  <script src="/static/three/SVGLoader.js"></script>
  <script src="/static/three/OrbitControls.js"></script>
  <script src="/static/three/tween.js"></script>
  <script src="/static/three/trail_data.js"></script>
  <script src="/static/three/trail_data_loop.js"></script>
</head>

<body>
  <div id="WebGL-output"></div>
  <div style="position: absolute; top: 10px; left: 10px">
    <!-- <a href="javascript:;" onclick="upfloor()">上楼</a>
    <a href="javascript:;" onclick="downfloor()">下楼</a> -->
    <a href="javascript:;" onclick="createPath('',0)" style="color: #ffffff">轨迹动画</a>
  </div>
  <script>
    var data = TRAIL_JSON_LOOP.data;
    var renderer, scene, camera, group;
    var space = 240;
    var planeList = [];
    var geometryArr = [];
    var materialArr = [];
    var offset_x = -290; // x中心点偏移量
    var offset_z = -241; // z中心点偏移量
    var duration = 1000; // 动画片段持续时间
    var pic_width = 580; // 图片宽度
    var pic_height = 475; // 图片高度
    var mockFloorData = [{
        imgURL: 1,
        floorName: 'F10'
      },
      {
        imgURL: 2,
        floorName: 'F11'
      },
      {
        imgURL: 3,
        floorName: 'F12'
      },
      {
        imgURL: 4,
        floorName: 'F13'
      }
    ]

    var targetRotation = 0;
    var arrows = []; // 路径点集合
    var arrowsLength = 50; // 路径点数量
    var t = 0.0; // 路径遍历点
    var s = 0.005; // 移动速度
    var path; // 目标路径导线
    var elevatorGroup = new THREE.Object3D();
    elevatorGroup.name = 'elevator'
    var isElevator = false;
    var currentElevator = [];
    var currentPathPointIndex = 0;

    // 动画trigger
    function upfloor(currentElevator, index, targetFloorName) {
      setTimeout(function () {
        ChapterTwo('up')
      }, 1000)
      setTimeout(function () {
        ChapterThree('up')
      }, 6000)
      if (targetFloorName){
        ChapterOne()
      }
      if (currentElevator) {
        setTimeout(function () {
          TrailPath(currentElevator, 'up')
        }, 3000)
      }
      if (index) {
        setTimeout(function () {
          createPath(targetFloorName, index)
        }, 9000)
      }
    }

    function downfloor(currentElevator, index, targetFloorName) {
      setTimeout(function () {
        ChapterTwo('down')
      }, 1000)
      setTimeout(function () {
        ChapterThree('down')
      }, 6000)
      if (targetFloorName){
        ChapterOne()
      }
      if (currentElevator) {
        setTimeout(function () {
          TrailPath(currentElevator, 'down')
        }, 3000)
      }
      if (index) {
        setTimeout(function () {
          createPath(targetFloorName, index)
        }, 9000)
      }
    }

    function init() {
      // 布置场景
      createScene() // 创建场景
      createCamera() // 创建相机
      createRenderer() // 创建渲染器
      createLight() // 创建灯光
      createGeneralGroup() // 创建整体分组
      createListener() // 创建监听函数

      // 布置调度
      createAlexHelper()
      createControl()

      // 创建楼层
      mockFloorData.forEach(function (item) {
        createFloor(item.imgURL, item.floorName)
      })

      // 动画就绪
      ChapterZero()
      ChapterOne()

      // 开始
      render()
    }

    init()

    // 0: 下楼 1: 上楼
    function structFloorInfo(startFloor, endFloor) {
      var s_floorAnti = startFloor.slice(0, 1)
      var s_floorNum = parseInt(startFloor.slice(1, startFloor.length))
      var e_floorAnti = endFloor.slice(0, 1)
      var e_floorNum = parseInt(endFloor.slice(1, endFloor.length))
      if (s_floorAnti === 'F' && e_floorAnti === 'B') return 0
      if (e_floorAnti === 'F' && s_floorAnti === 'B') return 1
      if (s_floorNum < e_floorNum) return 1
      if (s_floorNum > e_floorNum) return 0
    }

    var BEGIN_FLOOR;
    var END_FLOOR;
    // 确定轨迹开始的楼层
    function ChapterZero() {
      BEGIN_FLOOR = data[0].floorName
    }

    // step1: 放置所有起始楼层的最初位置
    function ChapterOne() {
      group.children.forEach(function (item) {
        if (item.name === BEGIN_FLOOR) {
          item.position.set(0, 0, 0)
          item.rotation.x = 0.3 * Math.PI
        } else if(structFloorInfo(BEGIN_FLOOR, item.name)) {
          item.position.y = 260
          item.rotation.x = 0
        }else if(!structFloorInfo(BEGIN_FLOOR, item.name)) {
          item.position.y = -260
          item.rotation.x = 0
        }
      })
    }

    // step2: 电梯楼层动画
    function ChapterTwo(type) {
      group.children.forEach(function (item) {
        animateLowerElevator(item, type === 'up' ? BEGIN_FLOOR : END_FLOOR, type)
        animateHigerElevator(item, type === 'up' ? END_FLOOR : BEGIN_FLOOR, type)
      })
    }

    // step3: 切换楼层动画
    function ChapterThree(type) {
      group.children.forEach(function (item) {
        animateLowerFloor(item, type === 'up' ? BEGIN_FLOOR : END_FLOOR, type)
        animateHigerFloor(item, type === 'up' ? END_FLOOR : BEGIN_FLOOR, type)
      })
    }

    // 动画参数板
    var transferBoard = {
      ROTATE_X: 0.15 * Math.PI, // 过渡偏转角
      ROTATE_Y: -0.1 * Math.PI, // 过渡偏转角
      UNROTATE_X: 0, // 电梯偏转角
      UNROTATE_Y: 0, // 电梯偏转角
      ORIROTATE_X: 0.3 * Math.PI, // 原始偏转角
      ORIROTATE_Y: 0, // 原始偏转角
      HIGH_POS: 260, // 最高点
      PASS_HIGH_POS: 130, // 过度点
      MIDDLE_POS: 0, // 显示区
      PASS_LOW_POS: -130, // 过渡点
      LOW_POS: -260, // 最低点
      OPACITY_BLOCK: 1, // 完全显示
      OPACITY_NONE: 0 // 完全隐藏
    }

    // 电梯动画片段: 低层变化过程
    function animateLowerElevator(item, floorName, type) {
      if (item.name === floorName) {
        var lowPositionStart = {
          x: item.position.x,
          y: item.position.y
        }
        var lowPositionEnd = {
          x: item.position.x,
          y: transferBoard.PASS_LOW_POS
        }
        var lowRotationStart = {
          x: item.rotation.x,
          y: item.rotation.y
        }
        var lowRotationEnd = {
          x: transferBoard.ROTATE_X,
          y: transferBoard.ROTATE_Y
        }
        var lowOpacityStart = {
          opacity: type === 'up' ? transferBoard.OPACITY_BLOCK : transferBoard.OPACITY_NONE
        }
        var lowOpacityEnd = {
          opacity: transferBoard.OPACITY_BLOCK
        }
        var lowAction1 = new TWEEN.Tween(lowPositionStart)
          .to(lowPositionEnd, duration)
          .onUpdate(function () {
            item.position.x = lowPositionStart.x;
            item.position.y = lowPositionStart.y;
          })
        var lowAction2 = new TWEEN.Tween(lowRotationStart)
          .to(lowRotationEnd, duration)
          .onUpdate(function () {
            item.rotation.x = lowRotationStart.x
            item.rotation.y = lowRotationStart.y
            lowAction3.start()
          })
        var lowAction3 = new TWEEN.Tween(lowOpacityStart)
          .to(lowOpacityEnd, duration)
          .onUpdate(function () {
            item.children.forEach(function (val) {
              if(val.name !== 'elevator') {
                val.material.opacity = lowOpacityStart.opacity
              }
            })
          })
        lowAction2.chain(lowAction1)
        lowAction2.start()
      }
    }

    // 电梯动画片段: 高层变化过程
    function animateHigerElevator(item, floorName, type) {
      if (item.name === floorName) {
        var highPositionStart = {
          x: item.position.x,
          y: item.position.y
        }
        var highPositionEnd = {
          x: item.position.x,
          y: transferBoard.PASS_HIGH_POS
        }
        var highRotationStart = {
          x: item.rotation.x,
          y: item.rotation.y
        }
        var highRotationEnd = {
          x: transferBoard.ROTATE_X,
          y: transferBoard.ROTATE_Y
        }
        var highOpacityStart = {
          opacity: type === 'up' ? transferBoard.OPACITY_NONE : transferBoard.OPACITY_BLOCK
        }
        var highOpacityEnd = {
          opacity: transferBoard.OPACITY_BLOCK
        }
        var highAction1 = new TWEEN.Tween(highPositionStart)
          .to(highPositionEnd, duration)
          .onUpdate(function () {
            item.position.x = highPositionStart.x;
            item.position.y = highPositionStart.y;
          })
        var highAction2 = new TWEEN.Tween(highRotationStart)
          .to(highRotationEnd, duration)
          .onUpdate(function () {
            item.rotation.x = highRotationStart.x
            item.rotation.y = highRotationStart.y
            highAction3.start()
          })
        var highAction3 = new TWEEN.Tween(highOpacityStart)
          .to(highOpacityEnd, duration)
          .onUpdate(function () {
            item.children.forEach(function (val) {
              if(val.name !== 'elevator') {
                val.material.opacity = highOpacityStart.opacity
              }
              
            })
          })
        highAction2.chain(highAction1)
        highAction2.start()
      }
    }

    // 楼层动画片段: 低层变化过程
    function animateLowerFloor(item, floorName, type) {
      if (item.name === floorName) {
        var lowPositionStart = {
          x: item.position.x,
          y: item.position.y
        }
        var lowPositionEnd = {
          x: item.position.x,
          y: type === 'up' ? transferBoard.LOW_POS : transferBoard.MIDDLE_POS
        }
        var lowRotationStart = {
          x: item.rotation.x,
          y: item.rotation.y
        }
        var lowRotationEnd = {
          x: type === 'up' ? transferBoard.UNROTATE_X : transferBoard.ORIROTATE_X,
          y: transferBoard.UNROTATE_Y
        }
        var lowOpacityStart = {
          opacity: transferBoard.OPACITY_BLOCK
        }
        var lowOpacityEnd = {
          opacity: type === 'up' ? transferBoard.OPACITY_NONE : transferBoard.OPACITY_BLOCK
        }
        var lowAction1 = new TWEEN.Tween(lowPositionStart)
          .to(lowPositionEnd, duration)
          .onUpdate(function () {
            item.position.x = lowPositionStart.x;
            item.position.y = lowPositionStart.y;
          })
        var lowAction2 = new TWEEN.Tween(lowRotationStart)
          .to(lowRotationEnd, duration)
          .onUpdate(function () {
            item.rotation.x = lowRotationStart.x
            item.rotation.y = lowRotationStart.y
            lowAction3.start()
          })
        var lowAction3 = new TWEEN.Tween(lowOpacityStart)
          .to(lowOpacityEnd, duration)
          .onUpdate(function () {
            item.children.forEach(function (val) {
              if(val.name !== 'elevator') {
                val.material.opacity = lowOpacityStart.opacity
              }
            })
          })
        lowAction2.chain(lowAction1)
        lowAction2.start()
      }
    }

    // 楼层动画片段: 高层变化过程
    function animateHigerFloor(item, floorName, type) {
      if (item.name === floorName) {
        var highPositionStart = {
          x: item.position.x,
          y: item.position.y
        }
        var highPositionEnd = {
          x: item.position.x,
          y: type === 'up' ? transferBoard.MIDDLE_POS : transferBoard.HIGH_POS
        }
        var highRotationStart = {
          x: item.rotation.x,
          y: item.rotation.y
        }
        var highRotationEnd = {
          x: type === 'up' ? transferBoard.ORIROTATE_X : transferBoard.ORIROTATE_Y,
          y: transferBoard.ORIROTATE_Y
        }
        var highOpacityStart = {
          opacity: transferBoard.OPACITY_BLOCK
        }
        var highOpacityEnd = {
          opacity: type === 'up' ? transferBoard.OPACITY_BLOCK : transferBoard.OPACITY_NONE
        }
        var highAction1 = new TWEEN.Tween(highPositionStart)
          .to(highPositionEnd, duration)
          .onUpdate(function () {
            item.position.x = highPositionStart.x;
            item.position.y = highPositionStart.y;
          })
        var highAction2 = new TWEEN.Tween(highRotationStart)
          .to(highRotationEnd, duration)
          .onUpdate(function () {
            item.rotation.x = highRotationStart.x
            item.rotation.y = highRotationStart.y
            highAction3.start()
          })
        var highAction3 = new TWEEN.Tween(highOpacityStart)
          .to(highOpacityEnd, duration)
          .onUpdate(function () {
            item.children.forEach(function (val) {
              if(val.name !== 'elevator') {
                val.material.opacity = highOpacityStart.opacity
              }
            })
          })
        highAction2.chain(highAction1)
        highAction2.start()
      }
    }

    function createGeneralGroup() {
      group = new THREE.Group();
      group.name = 'all_scene'
      scene.add(group)
    }

    function createFloor(url, groupName) {
      var floorGroup = new THREE.Group();
      var loader = new THREE.SVGLoader();

      loader.load('/static/origin-floor/' + url + '.svg', function (paths) {
        for (var i = 0; i < paths.length; i++) {
          var shapes = paths[i].toShapes(true)

          for (var j = 0; j < shapes.length; j++) {

            if (i === 0) continue

            var shape = shapes[j]
            var points = shape.getPoints()
            shape.autoClose = true

            var store = new Store(shape, groupName)
            store.mesh.updateMatrix();
            floorGroup.add(store.mesh)

            var edge = new Edge(points, groupName)
            edge.mesh.updateMatrix()
            floorGroup.add(edge.mesh)
          }
        }
      })

      loader.load('/static/origin-floor/bottom.svg', function (paths) {
        for (var i = 0; i < paths.length; i++) {
          var shapes = paths[i].toShapes(true)
          for (var j = 0; j < shapes.length; j++) {
            var shape = shapes[j];

            var plane = new Plane(shape, groupName)
            plane.mesh.updateMatrix()
            floorGroup.add(plane.mesh);
          }
        }
      })
      floorGroup.name = groupName
      group.add(floorGroup)
    }

    function createPath(floorName, currentPathPointIndex) {
      if (!floorName) {
        floorName = BEGIN_FLOOR
      }
      
      var count = currentPathPointIndex
      var floorGroup;
      
      group.children.forEach(function (item) {
        if (item.name === floorName) {
          floorGroup = item
        }
      })

      var timer1 = setInterval(function () {
        
        if (count % 2 === 0 && count <= data.length - 2) {
          var pathGroup = {
            start: !data[count].elevator ? data[count].pointInPath : data[count].point,
            end: !data[count + 1].elevator ? data[count + 1].pointInPath : data[count + 1].point
          }
          var path = new Path(pathGroup)
          path.line.position.y = 1
          path.line.rotation.x = 0.5 * Math.PI
          floorGroup.add(path.line)
        }
        
        if (data[count].capturePoint || data[count].elevator) {
          let obj = new THREE.Vector3(
            data[count].point.x - pic_width / 2,
            1,
            data[count].point.y - pic_height / 2
          )
          let circle = new Circle(obj)
          circle.mesh.rotation.x = -0.5 * Math.PI
          floorGroup.add(circle.mesh)
        }
        
        count += 1

        if (count === data.length){
          clearInterval(timer1)
        }

        if (count > currentPathPointIndex + 2 && data[count-1].elevator === true) {
          currentElevator[0] = data[count-1]
          currentElevator[1] = data[count]
          BEGIN_FLOOR = data[count-3].floorName
          END_FLOOR = data[count+1].floorName
          if (structFloorInfo(BEGIN_FLOOR, END_FLOOR)){
            upfloor(currentElevator, count, END_FLOOR)
          } else {
            downfloor(currentElevator, count, END_FLOOR)
          }
          clearInterval(timer1)
        }

      }, 100)
    }

    // 路径
    function Path(group) {
      var path = new THREE.Path([new THREE.Vector2(group.start.x - 580 / 2, group.start.y - 475 / 2)]);
      path.lineTo(group.end.x - 580 / 2, group.end.y - 475 / 2)
      var points = path.getPoints();
      var geometry = new THREE.BufferGeometry().setFromPoints(points)
      var material = new THREE.LineBasicMaterial({
        transparent: true,
        color: 0xFFE000
      })
      this.line = new THREE.Line(geometry, material);
      this.line.name = 'path'
    }
    
    function Circle(vector) {
      var geom = new THREE.CircleGeometry(5, 50)
      var material = new THREE.MeshBasicMaterial({ color: '#FFE000' })
      this.mesh = new THREE.Mesh(geom, material);
      this.mesh.position.set(vector.x, vector.y, vector.z)
    }

    // 电梯轨迹
    function TrailPath(currentElevator, type) {
      var rectPath = new THREE.Path();
      var position = {
        x: currentElevator[0].point.x - pic_width / 2,
        y: currentElevator[0].point.y - pic_height / 2,
        x1: currentElevator[1].point.x - pic_width / 2,
        y1: currentElevator[1].point.y - pic_height / 2
      }
      var points = [
        new THREE.Vector3(position.x, transferBoard.PASS_LOW_POS + 15, position.y),
        new THREE.Vector3(position.x1, transferBoard.PASS_HIGH_POS + 15, position.y1),
      ]
      // 画线段
      for (var i = 0; i<=arrowsLength; i++){
        arrows[i] = new THREE.Mesh(
          new THREE.CubeGeometry(1, 1, 3),
          new THREE.MeshBasicMaterial({ color: '#FFE000' })
        );
        arrows[i].rotation.set(0.5 * Math.PI, 0, 0);
        elevatorGroup.add(arrows[i]);
      }

      // 画点
      var circle = [];
      for (var j = 0; j < points.length; j++) {
        circle[j] = new Circle(points[j])
        circle[j].mesh.rotation.x = -0.3 * Math.PI
        scene.add(circle[j].mesh)
      }
      scene.add(elevatorGroup);
      
      var animateEnd = 65
      var intervalCount = 0
      rectPath.moveTo(position.x, type === 'up' ? transferBoard.PASS_LOW_POS + 15 : transferBoard.PASS_HIGH_POS + 15, position.y)
      rectPath.lineTo(position.x1, type === 'up' ? transferBoard.PASS_HIGH_POS + 15 : transferBoard.PASS_LOW_POS + 15, position.y1)
      path = rectPath;
      
      var timer2 = setInterval(function(){
        pathRender()
        if (intervalCount >= animateEnd) {
          clearInterval(timer2)
          scene.remove(elevatorGroup)
          scene.remove(circle[0].mesh)
          scene.remove(circle[1].mesh)
        } else {
          intervalCount++
        }
      }, 50)
    }

    function pathRender() {
      t = (t + s) % 1; // 增量t同时保持再0.0和1.0之间
      for (let i = 0; i < arrowsLength; i++) {
        var ti = ((i / arrowsLength) + t) % 1.0;
        var p = path.getPoint(ti);
        var pn = path.getPoint((ti + s) % 1.0);
        if (p != null && pn != null) {
          // 移动到当前位置
          arrows[i].position.x = p.x;
          arrows[i].position.y = p.y;
          // 基于下一个位置获得定位
          arrows[i].rotation.z = Math.atan2(pn.y - p.y, pn.x - p.x);
        }
      }
      elevatorGroup.rotation.y += (targetRotation - elevatorGroup.rotation.y) * 0.001;
    }

    var opacity = 0
    // 单层楼色块
    function Store(shape, groupName) {
      var geometryBuffer = new THREE.ExtrudeBufferGeometry(shape, {
        depth: 8,
        bevelEnabled: false
      })

      var geometry = new THREE.Geometry()
      geometry.fromBufferGeometry(geometryBuffer)

      var material = new THREE.MeshBasicMaterial({
        color: new THREE.Color('#5F719E'),
        transparent: true,
        opacity: groupName === BEGIN_FLOOR ? 1 : opacity,
        side: THREE.DoubleSide,
        // vertexColors: THREE.FaceColors
      })

      this.mesh = new THREE.Mesh(geometry, material)
      this.mesh.rotation.set(0.5 * Math.PI, 0, 0)
      this.mesh.position.set(offset_x, 8, offset_z)
      this.mesh.name = 'store'
      this.mesh.geometry.faces.forEach(function (face) {
        if (face.normal.y !== 0) {
          // face.color = new THREE.Color('#0E1239')
        }
      })
    }

    // 单层楼色块描边
    function Edge(points, groupName) {
      var geometry = new THREE.BufferGeometry().setFromPoints(points)
      var material = new THREE.LineBasicMaterial({
        color: '#2A4586',
        transparent: true,
        opacity: groupName === BEGIN_FLOOR ? 1 : opacity
      })
      this.mesh = new THREE.Line(geometry, material)
      this.mesh.rotation.set(0.5 * Math.PI, 0, 0)
      this.mesh.position.set(offset_x, 8, offset_z)
      this.mesh.name = 'edge'
    }

    // 单层楼底座
    function Plane(shape, groupName) {
      var geometry = new THREE.ShapeBufferGeometry(shape);
      var material = new THREE.MeshBasicMaterial({
        color: '#2A4586',
        side: THREE.DoubleSide,
        transparent: true,
        opacity: groupName === BEGIN_FLOOR ? 1 : opacity
      })
      this.mesh = new THREE.Mesh(geometry, material);
      this.mesh.rotation.set(0.5 * Math.PI, 0, 0)
      this.mesh.position.set(offset_x, 0, offset_z)
      this.mesh.name = 'plane'
    }

    function createRenderer() {
      renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true
      })
      renderer.setSize(window.innerWidth, window.innerHeight)
      renderer.setClearColor('#ffffff', 1.0)
      document.getElementById("WebGL-output").appendChild(renderer.domElement)
    }

    function createListener() {
      window.addEventListener('resize', onWindowResize, false)
    }

    // 布景
    function createScene() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color('#17151a')
    }

    function createCamera() {
      camera = new THREE.OrthographicCamera(
        window.innerWidth / -2.5,
        window.innerWidth / 2.5,
        window.innerHeight / 2.5,
        window.innerHeight / -2.5,
        0.1, 10000
      )
      camera.position.set(0, 0, 400)
      camera.lookAt(0, 0, 0);
      scene.add(camera)
    }

    function createLight() {
      var light = new THREE.PointLight('#435175', 0.8)
      camera.add(light)
    }

    // 控制函数
    function createControl() {
      controls = new THREE.OrbitControls(camera);
      // controls.maxPolarAngle = 1.28;//上下两极的可视区域的最大角度
      // controls.minPolarAngle = 1.28;//上下两极的可视区域最小角度
      // controls.dampingFactor = 0.25;
      controls.enableZoom = true;
      controls.enableRotate = true;
      controls.screenSpacePanning = true;
    }

    function createAlexHelper() {
      var axesHelper = new THREE.AxesHelper(10)
      scene.add(axesHelper)
    }

    // 渲染函数
    function render() {
      requestAnimationFrame(render)
      TWEEN.update()
      
      renderer.render(scene, camera)
    }

    function onWindowResize() {
      camera.left = window.innerWidth / -2;
      camera.right = window.innerWidth / 2;
      camera.top = window.innerHeight / 2;
      camera.bottom = window.innerHeight / -2;
      camera.updateProjectionMatrix()
      renderer.setSize(window.innerWidth, window.innerHeight)
    }

  </script>
</body>

</html>
