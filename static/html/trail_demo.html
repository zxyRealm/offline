<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <style>
    html,
    body {
      margin: 0px;
      padding: 0px
    }

  </style>
  <script src="/static/three/three.min.js"></script>
  <script src="/static/three/SVGLoader.js"></script>
  <script src="/static/three/OrbitControls.js"></script>
  <script src="/static/three/tween.js"></script>
  <script src="/static/three/trail_data_up.js"></script>
</head>

<body>
  <div id="WebGL-output"></div>
  <div style="position: absolute; top: 10px; left: 10px">
    <!-- <a href="javascript:;" onclick="upfloor()">上楼</a>
    <a href="javascript:;" onclick="downfloor()">下楼</a> -->
    <a href="javascript:;" onclick="createPath('',0)" style="color: #ffffff">轨迹动画</a>
  </div>
  <script>
    // var data = TRAIL_JSON_LOOP.data;
    var data;
    var renderer, scene, camera, group;
    var space = 240;
    var planeList = [];
    var geometryArr = [];
    var materialArr = [];
    var offset_x = -290; // x中心点偏移量
    var offset_z = -241; // z中心点偏移量
    var duration = 1000; // 动画片段持续时间
    var pic_width = 0; // 图片宽度
    var pic_height = 0; // 图片高度
    var sceneCube = 2.5; // 场景立方体系数
    var opacity = 0
    var mockFloorData = [{
        imgURL: 1,
        floorName: 'F10'
      },
      {
        imgURL: 2,
        floorName: 'F11'
      },
      {
        imgURL: 3,
        floorName: 'F12'
      },
      {
        imgURL: 4,
        floorName: 'F13'
      }
    ]

    var targetRotation = 0;
    var arrows = []; // 路径点集合
    var arrowsLength = 35; // 路径点数量
    var t = 0.0; // 路径遍历点
    var s = 0.005; // 移动速度
    var path; // 目标路径导线
    var elevatorGroup = new THREE.Object3D();
    elevatorGroup.name = 'elevator'
    var isElevator = false;
    var currentElevator = [];
    var currentPathPointIndex = 0;

    // 动画参数板
    var TRANSFER_BOARD = {
      HALFROTATE: 0.5 * Math.PI,
      ARROWROTATE: 0.5 * Math.PI,
      ORIGIN_NONE_X: 0, // 隐藏楼层的初始偏转角
      ORIGIN_PLAY_X: 0.17 * Math.PI, // 显示楼层的初始偏转角
      ORIGIN_Y: -0.02 * Math.PI, // 隐藏楼层和显示楼层的共同初始Y偏转角
      ROTATE_X: 0.13 * Math.PI, // 过渡偏转角
      ROTATE_Y: -0.1 * Math.PI, // 过渡偏转角
      HIGH_POS: 210, // 最高点
      PASS_HIGH_POS: 140, // 过度点
      MIDDLE_POS: 0, // 显示区
      PASS_LOW_POS: -60, // 过渡点
      LOW_POS: -210, // 最低点
      OPACITY_BLOCK: 1, // 完全显示
      OPACITY_NONE: 0 // 完全隐藏
    }

    var BEGIN_FLOOR;
    var END_FLOOR;

    // 调色板
    var PALLETTE = {
      LIGHT: '#FFFFFF', // 灯光
      STORE: '#4E98F2', // 商店
      EDGE: '#005BC9', // 描边
      PLANE: '#0F1252', // 底座
      PATH: '#FFE000', // 路径
      CIRCLE: '#FFE000', // 抓拍点
      ELEVATOR: '#FFE000' // 电梯点
    }

    function getTrailData(trailData) {
      data = trailData
      // data = TRAIL_JSON_UP.data;
      init()
    }

    // 动画trigger
    function upfloor(currentElevator, index, targetFloorName) {
      setTimeout(function () {
        ChapterTwo('up')
      }, 1000)
      setTimeout(function () {
        ChapterThree('up')
      }, 6000)
      if (targetFloorName) {
        ChapterOne()
      }
      if (currentElevator) {
        setTimeout(function () {
          TrailPath(currentElevator, 'up')
        }, 3000)
      }
      if (index) {
        setTimeout(function () {
          createPath(targetFloorName, index)
        }, 9000)
      }
    }

    function downfloor(currentElevator, index, targetFloorName) {
      setTimeout(function () {
        ChapterTwo('down')
      }, 1000)
      setTimeout(function () {
        ChapterThree('down')
      }, 6000)
      if (targetFloorName) {
        ChapterOne()
      }
      if (currentElevator) {
        setTimeout(function () {
          TrailPath(currentElevator, 'down')
        }, 3000)
      }
      if (index) {
        setTimeout(function () {
          createPath(targetFloorName, index)
        }, 9000)
      }
    }

    function init() {
      // 布置场景
      createScene() // 创建场景
      createCamera() // 创建相机
      createRenderer() // 创建渲染器
      createLight() // 创建灯光
      createGeneralGroup() // 创建整体分组
      createListener() // 创建监听函数

      // 创建楼层
      mockFloorData.forEach(function (item) {
        createFloor(item.imgURL, item.floorName)
      })

      // 布置调度
      createAlexHelper()
      createControl()

      ChapterZero()
      ChapterOne()

      // 开始
      render()
    }

    // setTimeout(function(){
    loadSignal()
    // }, 1000)

    function loadSignal() {
      window.parent.postMessage({
        cmd: 'trail-load_signal',
        params: {}
      }, '*');
    }

    // 0: 下楼 1: 上楼
    function structFloorInfo(startFloor, endFloor) {
      var s_floorAnti = startFloor.slice(0, 1)
      var s_floorNum = parseInt(startFloor.slice(1, startFloor.length))
      var e_floorAnti = endFloor.slice(0, 1)
      var e_floorNum = parseInt(endFloor.slice(1, endFloor.length))
      if (s_floorAnti === 'F' && e_floorAnti === 'B') return 0
      if (e_floorAnti === 'F' && s_floorAnti === 'B') return 1
      if (s_floorNum < e_floorNum) return 1
      if (s_floorNum > e_floorNum) return 0
    }

    function calcFloor(startFloor, endFloor) {
      var s_floorNum = parseInt(startFloor.slice(1, startFloor.length))
      var e_floorNum = parseInt(endFloor.slice(1, endFloor.length))
      return Math.abs(s_floorNum - e_floorNum)
    }

    // 确定轨迹开始的楼层
    function ChapterZero() {
      BEGIN_FLOOR = data[0].floorName
    }

    // step1: 放置所有起始楼层的最初位置
    function ChapterOne() {
      group.children.forEach(function (item) {
        if (item.name === BEGIN_FLOOR) {
          item.position.set(0, 0, 0)
          item.rotation.x = TRANSFER_BOARD.ORIGIN_PLAY_X
          item.rotation.y = TRANSFER_BOARD.ORIGIN_Y
        } else if (structFloorInfo(BEGIN_FLOOR, item.name)) {
          item.position.y = TRANSFER_BOARD.HIGH_POS
          item.rotation.x = TRANSFER_BOARD.ORIGIN_NONE_X
          item.rotation.y = TRANSFER_BOARD.ORIGIN_Y
        } else if (!structFloorInfo(BEGIN_FLOOR, item.name)) {
          item.position.y = TRANSFER_BOARD.LOW_POS
          item.rotation.x = TRANSFER_BOARD.ORIGIN_NONE_X
          item.rotation.y = TRANSFER_BOARD.ORIGIN_Y
        }
      })
    }

    // step2: 电梯楼层动画
    function ChapterTwo(type) {
      group.children.forEach(function (item) {
        animateLowerElevator(item, type === 'up' ? BEGIN_FLOOR : END_FLOOR, type)
        animateHigerElevator(item, type === 'up' ? END_FLOOR : BEGIN_FLOOR, type)
      })
      // animateMiddleFloor()
    }

    // step3: 切换楼层动画
    function ChapterThree(type) {
      group.children.forEach(function (item) {
        animateLowerFloor(item, type === 'up' ? BEGIN_FLOOR : END_FLOOR, type)
        animateHigerFloor(item, type === 'up' ? END_FLOOR : BEGIN_FLOOR, type)
      })
    }

    // 电梯动画片段: 低层变化过程
    function animateLowerElevator(item, floorName, type) {
      if (item.name === floorName) {
        var lowPositionStart = {
          x: item.position.x,
          y: item.position.y
        }
        var lowPositionEnd = {
          x: item.position.x,
          y: TRANSFER_BOARD.PASS_LOW_POS
        }
        var lowRotationStart = {
          x: item.rotation.x,
          y: item.rotation.y
        }
        var lowRotationEnd = {
          x: TRANSFER_BOARD.ROTATE_X,
          y: TRANSFER_BOARD.ROTATE_Y
        }
        var lowOpacityStart = {
          opacity: type === 'up' ? TRANSFER_BOARD.OPACITY_BLOCK : TRANSFER_BOARD.OPACITY_NONE
        }
        var lowOpacityEnd = {
          opacity: TRANSFER_BOARD.OPACITY_BLOCK
        }
        var lowAction1 = new TWEEN.Tween(lowPositionStart)
          .to(lowPositionEnd, duration)
          .onUpdate(function () {
            item.position.x = lowPositionStart.x;
            item.position.y = lowPositionStart.y;
          })
        var lowAction2 = new TWEEN.Tween(lowRotationStart)
          .to(lowRotationEnd, duration)
          .onUpdate(function () {
            item.rotation.x = lowRotationStart.x
            item.rotation.y = lowRotationStart.y
            lowAction3.start()
          })
        var lowAction3 = new TWEEN.Tween(lowOpacityStart)
          .to(lowOpacityEnd, duration)
          .onUpdate(function () {
            item.children.forEach(function (val) {
              if (val.name !== 'elevator') {
                val.material.opacity = lowOpacityStart.opacity
              }
            })
          })
        lowAction2.chain(lowAction1)
        lowAction2.start()
      }
    }

    // 电梯动画片段: 高层变化过程
    function animateHigerElevator(item, floorName, type) {
      if (item.name === floorName) {
        var highPositionStart = {
          x: item.position.x,
          y: item.position.y
        }
        var highPositionEnd = {
          x: item.position.x,
          y: TRANSFER_BOARD.PASS_HIGH_POS
        }
        var highRotationStart = {
          x: item.rotation.x,
          y: item.rotation.y
        }
        var highRotationEnd = {
          x: TRANSFER_BOARD.ROTATE_X,
          y: TRANSFER_BOARD.ROTATE_Y
        }
        var highOpacityStart = {
          opacity: type === 'up' ? TRANSFER_BOARD.OPACITY_NONE : TRANSFER_BOARD.OPACITY_BLOCK
        }
        var highOpacityEnd = {
          opacity: TRANSFER_BOARD.OPACITY_BLOCK
        }
        var highAction1 = new TWEEN.Tween(highPositionStart)
          .to(highPositionEnd, duration)
          .onUpdate(function () {
            item.position.x = highPositionStart.x;
            item.position.y = highPositionStart.y;
          })
        var highAction2 = new TWEEN.Tween(highRotationStart)
          .to(highRotationEnd, duration)
          .onUpdate(function () {
            item.rotation.x = highRotationStart.x
            item.rotation.y = highRotationStart.y
            highAction3.start()
          })
        var highAction3 = new TWEEN.Tween(highOpacityStart)
          .to(highOpacityEnd, duration)
          .onUpdate(function () {
            item.children.forEach(function (val) {
              if (val.name !== 'elevator') {
                val.material.opacity = highOpacityStart.opacity
              }
            })
          })
        highAction2.chain(highAction1)
        highAction2.start()
      }
    }

    // 楼层动画片段: 低层变化过程
    function animateLowerFloor(item, floorName, type) {
      if (item.name === floorName) {
        var lowPositionStart = {
          x: item.position.x,
          y: item.position.y
        }
        var lowPositionEnd = {
          x: item.position.x,
          y: type === 'up' ? TRANSFER_BOARD.LOW_POS : TRANSFER_BOARD.MIDDLE_POS
        }
        var lowRotationStart = {
          x: item.rotation.x,
          y: item.rotation.y
        }
        var lowRotationEnd = {
          x: type === 'up' ? TRANSFER_BOARD.ORIGIN_NONE_X : TRANSFER_BOARD.ORIGIN_PLAY_X,
          y: TRANSFER_BOARD.ORIGIN_Y
        }
        var lowOpacityStart = {
          opacity: TRANSFER_BOARD.OPACITY_BLOCK
        }
        var lowOpacityEnd = {
          opacity: type === 'up' ? TRANSFER_BOARD.OPACITY_NONE : TRANSFER_BOARD.OPACITY_BLOCK
        }
        var lowAction1 = new TWEEN.Tween(lowPositionStart)
          .to(lowPositionEnd, duration)
          .onUpdate(function () {
            item.position.x = lowPositionStart.x;
            item.position.y = lowPositionStart.y;
          })
        var lowAction2 = new TWEEN.Tween(lowRotationStart)
          .to(lowRotationEnd, duration)
          .onUpdate(function () {
            item.rotation.x = lowRotationStart.x
            item.rotation.y = lowRotationStart.y
            lowAction3.start()
          })
        var lowAction3 = new TWEEN.Tween(lowOpacityStart)
          .to(lowOpacityEnd, duration)
          .onUpdate(function () {
            item.children.forEach(function (val) {
              if (val.name !== 'elevator') {
                val.material.opacity = lowOpacityStart.opacity
              }
            })
          })
        lowAction2.chain(lowAction1)
        lowAction2.start()
      }
    }

    // 楼层动画片段: 高层变化过程
    function animateHigerFloor(item, floorName, type) {
      if (item.name === floorName) {
        var highPositionStart = {
          x: item.position.x,
          y: item.position.y
        }
        var highPositionEnd = {
          x: item.position.x,
          y: type === 'up' ? TRANSFER_BOARD.MIDDLE_POS : TRANSFER_BOARD.HIGH_POS
        }
        var highRotationStart = {
          x: item.rotation.x,
          y: item.rotation.y
        }
        var highRotationEnd = {
          x: type === 'up' ? TRANSFER_BOARD.ORIGIN_PLAY_X : TRANSFER_BOARD.ORIGIN_NONE_X,
          y: TRANSFER_BOARD.ORIGIN_Y
        }
        var highOpacityStart = {
          opacity: TRANSFER_BOARD.OPACITY_BLOCK
        }
        var highOpacityEnd = {
          opacity: type === 'up' ? TRANSFER_BOARD.OPACITY_BLOCK : TRANSFER_BOARD.OPACITY_NONE
        }
        var highAction1 = new TWEEN.Tween(highPositionStart)
          .to(highPositionEnd, duration)
          .onUpdate(function () {
            item.position.x = highPositionStart.x;
            item.position.y = highPositionStart.y;
          })
        var highAction2 = new TWEEN.Tween(highRotationStart)
          .to(highRotationEnd, duration)
          .onUpdate(function () {
            item.rotation.x = highRotationStart.x
            item.rotation.y = highRotationStart.y
            highAction3.start()
          })
        var highAction3 = new TWEEN.Tween(highOpacityStart)
          .to(highOpacityEnd, duration)
          .onUpdate(function () {
            item.children.forEach(function (val) {
              if (val.name !== 'elevator') {
                val.material.opacity = highOpacityStart.opacity
              }
            })
          })
        highAction2.chain(highAction1)
        highAction2.start()
      }
    }

    // 动画片段：中间楼层的显示和隐藏
    function animateMiddleFloor(){
      if (calcFloor(BEGIN_FLOOR, END_FLOOR) === 1) {

      }
    }

    function createGeneralGroup() {
      group = new THREE.Group();
      group.name = 'all_scene'
      scene.add(group)
    }

    function createFloor(url, groupName) {
      var floorGroup = new THREE.Group();
      var loader = new THREE.SVGLoader();

      loader.load('/static/origin-floor/' + url + '.svg', function (paths) {
        for (var i = 0; i < paths.length; i++) {
          var shapes = paths[i].toShapes(true)

          for (var j = 0; j < shapes.length; j++) {

            if (i === 0) continue

            var shape = shapes[j]
            var points = shape.getPoints()
            shape.autoClose = true

            var store = new Store(shape, groupName)
            store.mesh.updateMatrix();
            floorGroup.add(store.mesh)

            var edge = new Edge(points, groupName)
            edge.mesh.updateMatrix()
            floorGroup.add(edge.mesh)
          }
        }
      })

      loader.load('/static/origin-floor/bottom.svg', function (paths) {
        for (var i = 0; i < paths.length; i++) {
          var shapes = paths[i].toShapes(true)
          for (var j = 0; j < shapes.length; j++) {
            var shape = shapes[j];

            var plane = new Plane(shape, groupName)
            plane.mesh.updateMatrix()
            floorGroup.add(plane.mesh);

            var text = new TextSprite(groupName)
            floorGroup.add(text.textObj)
          }
        }
      })

      floorGroup.name = groupName
      group.add(floorGroup)
    }

    function createPath(floorName, currentPathPointIndex) {
      if (!floorName) {
        floorName = BEGIN_FLOOR
      }

      var count = currentPathPointIndex
      var floorGroup;
      var positionY = 9

      group.children.forEach(function (item) {
        if (item.name === floorName) {
          floorGroup = item
        }
      })

      var timer1 = setInterval(function () {

        if (count % 2 === 0 && count <= data.length - 2) {
          var pathGroup = {
            start: {
              x: data[count].elevator || data[count].capturePoint ? data[count].point.x : data[count].pointInPath
                .x,
              y: data[count].elevator || data[count].capturePoint ? -data[count].point.y : -data[count].pointInPath
                .y
            },
            end: {
              x: data[count + 1].elevator || data[count + 1].capturePoint ? data[count + 1].point.x : data[count +
                1].pointInPath.x,
              y: data[count + 1].elevator || data[count + 1].capturePoint ? -data[count + 1].point.y : -data[
                count + 1].pointInPath.y
            }
          }

          var path = new Path(pathGroup)
          path.line.position.y = positionY
          path.line.rotation.x = 0.5 * Math.PI
          floorGroup.add(path.line)
        }

        if (data[count].capturePoint) {
          let obj = new THREE.Vector3(
            data[count].point.x - pic_width / 2,
            positionY,
            -data[count].point.y - pic_height / 2
          )
          let circle = new Circle(obj)
          circle.mesh.rotation.x = -0.5 * Math.PI
          console.log(circle.mesh)
          floorGroup.add(circle.mesh)
        }

        count += 1

        if (count === data.length) {
          clearInterval(timer1)
        }

        if (count > currentPathPointIndex + 2 && data[count - 1].elevator === true) {
          currentElevator[0] = data[count - 1]
          currentElevator[1] = data[count]
          BEGIN_FLOOR = data[count - 3].floorName
          END_FLOOR = data[count + 1].floorName
          if (structFloorInfo(BEGIN_FLOOR, END_FLOOR)) {
            upfloor(currentElevator, count, END_FLOOR)
          } else {
            downfloor(currentElevator, count, END_FLOOR)
          }
          clearInterval(timer1)
        }

      }, 100)
    }

    // 电梯轨迹
    function TrailPath(currentElevator, type) {
      var rectPath = new THREE.Path();
      var position = {
        x: currentElevator[0].point.x - pic_width / 2,
        y: -currentElevator[0].point.y - pic_height / 2,
        x1: currentElevator[1].point.x - pic_width / 2,
        y1: -currentElevator[1].point.y - pic_height / 2
      }
      var points = [
        new THREE.Vector3(position.x, TRANSFER_BOARD.PASS_LOW_POS + 15, position.y),
        new THREE.Vector3(position.x1, TRANSFER_BOARD.PASS_HIGH_POS + 15, position.y1),
      ]
      // 画线段
      for (var i = 0; i <= arrowsLength; i++) {
        arrows[i] = new THREE.Mesh(
          new THREE.CubeGeometry(1, 1, 3),
          new THREE.MeshBasicMaterial({
            color: PALLETTE.ELEVATOR
          })
        );
        arrows[i].rotation.set(TRANSFER_BOARD.HALFROTATE, 0, 0);
        elevatorGroup.add(arrows[i]);
      }

      // 画点
      var circle = [];
      for (var j = 0; j < points.length; j++) {
        circle[j] = new Circle(points[j])
        circle[j].mesh.rotation.x = -0.3 * Math.PI
        scene.add(circle[j].mesh)
      }
      scene.add(elevatorGroup);

      var animateEnd = 65
      var intervalCount = 0
      rectPath.moveTo(position.x, type === 'up' ? TRANSFER_BOARD.PASS_LOW_POS + 15 : TRANSFER_BOARD.PASS_HIGH_POS + 15,
        position.y)
      rectPath.lineTo(position.x1, type === 'up' ? TRANSFER_BOARD.PASS_HIGH_POS + 15 : TRANSFER_BOARD.PASS_LOW_POS + 15,
        position.y1)
      path = rectPath;

      var timer2 = setInterval(function () {
        pathRender()
        if (intervalCount >= animateEnd) {
          clearInterval(timer2)
          scene.remove(elevatorGroup)
          scene.remove(circle[0].mesh)
          scene.remove(circle[1].mesh)
        } else {
          intervalCount++
        }
      }, 50)
    }

    function pathRender() {
      t = (t + s) % 1; // 增量t同时保持再0.0和1.0之间
      for (let i = 0; i < arrowsLength; i++) {
        var ti = ((i / arrowsLength) + t) % 1.0;
        var p = path.getPoint(ti);
        var pn = path.getPoint((ti + s) % 1.0);
        if (p != null && pn != null) {
          // 移动到当前位置
          arrows[i].position.x = p.x;
          arrows[i].position.y = p.y;
          // 基于下一个位置获得定位
          arrows[i].rotation.z = Math.atan2(pn.y - p.y, pn.x - p.x);
        }
      }
      elevatorGroup.rotation.y += (targetRotation - elevatorGroup.rotation.y) * 0.001;
    }

    /*****************************
     * ***************************
     * ********** 物体类 **********
     * ***************************
     * ***************************/

    // 单层楼色块
    function Store(shape, groupName) {
      var geometryBuffer = new THREE.ExtrudeBufferGeometry(shape, {
        depth: 4,
        bevelEnabled: false
      })

      var geometry = new THREE.Geometry()
      geometry.fromBufferGeometry(geometryBuffer)

      var material = new THREE.MeshBasicMaterial({
        color: new THREE.Color(PALLETTE.STORE),
        transparent: true,
        opacity: groupName === BEGIN_FLOOR ? 1 : opacity,
        side: THREE.DoubleSide,
        // vertexColors: THREE.FaceColors
      })

      this.mesh = new THREE.Mesh(geometry, material)
      this.mesh.rotation.set(TRANSFER_BOARD.HALFROTATE, 0, 0)
      this.mesh.position.set(offset_x, 8, offset_z)
      this.mesh.name = 'store'
      this.mesh.geometry.faces.forEach(function (face) {
        if (face.normal.y !== 0) {
          // face.color = new THREE.Color('#0E1239')
        }
      })
    }

    // 单层楼色块描边
    function Edge(points, groupName) {
      var geometry = new THREE.BufferGeometry().setFromPoints(points)
      var material = new THREE.LineBasicMaterial({
        color: PALLETTE.EDGE,
        transparent: true,
        opacity: groupName === BEGIN_FLOOR ? 1 : opacity
      })
      this.mesh = new THREE.Line(geometry, material)
      this.mesh.rotation.set(TRANSFER_BOARD.HALFROTATE, 0, 0)
      this.mesh.position.set(offset_x, 8, offset_z)
      this.mesh.name = 'edge'
    }

    // 单层楼底座
    function Plane(shape, groupName) {
      var geometry = new THREE.ShapeBufferGeometry(shape);
      var material = new THREE.MeshBasicMaterial({
        color: PALLETTE.PLANE,
        side: THREE.DoubleSide,
        transparent: true,
        opacity: groupName === BEGIN_FLOOR ? 0.2 : opacity
      })
      this.mesh = new THREE.Mesh(geometry, material);
      this.mesh.rotation.set(TRANSFER_BOARD.HALFROTATE, 0, 0)
      this.mesh.position.set(offset_x, 0, offset_z)
      this.mesh.name = 'plane'
    }

    function MiddlePlane(){
      var geom = new THREE.PlaneGeometry(580, 428, 32)
      var material = new THREE.MeshBasicMaterial({
        transparent: true,
        side: THREE.DoubleSide,
        color: PALLETTE.PLANE,
        opacity: 0.2
      })
      this.mesh = new THREE.Mesh(geom, material)
      this.mesh.rotation.set(TRANSFER_BOARD.HALFROTATE, 0, 0)
      this.mesh.name = 'middlePlane'
    }

    // 路径
    function Path(group) {
      var path = new THREE.Path([new THREE.Vector2(group.start.x - pic_width / 2, group.start.y - pic_height / 2 - 25)]);
      path.lineTo(group.end.x - pic_width / 2, group.end.y - pic_height / 2 - 25)
      var points = path.getPoints();
      var geometry = new THREE.BufferGeometry().setFromPoints(points)
      var material = new THREE.LineBasicMaterial({
        transparent: true,
        color: PALLETTE.PATH
      })
      this.line = new THREE.Line(geometry, material);
      this.line.name = 'path'
    }

    // 摄像头点
    function Circle(vector) {
      var geom = new THREE.CircleGeometry(5, 50)
      var material = new THREE.MeshBasicMaterial({
        transparent: true,
        color: PALLETTE.CIRCLE
      })
      this.mesh = new THREE.Mesh(geom, material);
      this.mesh.position.set(vector.x, vector.y, vector.z - 25)
      this.mesh.name = 'circle'
    }

    function TextSprite(text) {
      var canvas = document.createElement('canvas')
      var ctx = canvas.getContext('2d')
      var cz = camera.position.z // 摄像头z轴视距
      canvas.width = text.length * 170
      canvas.height = canvas.width / 4
      ctx.fillStyle = '#ffffff'
      ctx.font = '600 104px Microsoft YaHei Arial'
      ctx.textAlign = 'left'
      ctx.fillText(text, 0, 104)
      var texture = new THREE.Texture(canvas)
      texture.needsUpdate = true
      // 使用Sprite显示文字
      var material = new THREE.SpriteMaterial({
        map: texture,
        color: 0xffffff,
        transparent: true,
        opacity: text === BEGIN_FLOOR ? 1 : opacity
      })
      this.textObj = new THREE.Sprite(material)
      this.textObj.name = 'text'
      this.textObj.scale.set(cz * 0.027 * text.length, cz * 0.008 * text.length, 250)
      this.textObj.position.set(290, 0, 0)
    }

    /****************************
     * **************************
     * ********** 布景 **********
     * **************************
     *****************************/

    // 场景
    function createScene() {
      scene = new THREE.Scene();
    }

    // 相机
    function createCamera() {
      // camera = new THREE.OrthographicCamera(
      //   window.innerWidth / -sceneCube,
      //   window.innerWidth / sceneCube,
      //   window.innerHeight / sceneCube,
      //   window.innerHeight / -sceneCube,
      //   0.1, 10000
      // )
      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 10000)
      // camera.position.set(762, 399, 1170)
      camera.position.set(0, 0, 550)
      camera.lookAt(0, 0, 0);
      scene.add(camera)
    }

    // 灯光
    function createLight() {
      var light = new THREE.PointLight(PALLETTE.LIGHT, 0.8)
      camera.add(light)
    }

    // 渲染器
    function createRenderer() {
      renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true
      })
      renderer.setSize(window.innerWidth, window.innerHeight)
      document.getElementById("WebGL-output").appendChild(renderer.domElement)
    }

    // 监听器
    function createListener() {
      window.addEventListener('resize', onWindowResize, false)
    }

    // 控制函数
    function createControl() {
      controls = new THREE.OrbitControls(camera);
      // controls.maxPolarAngle = 1.28;//上下两极的可视区域的最大角度
      // controls.minPolarAngle = 1.28;//上下两极的可视区域最小角度
      // controls.dampingFactor = 0.25;
      controls.enableZoom = true;
      controls.enableRotate = true;
      controls.screenSpacePanning = true;
    }

    function createAlexHelper() {
      var axesHelper = new THREE.AxesHelper(100)
      scene.add(axesHelper)
    }

    // 渲染函数
    function render() {
      requestAnimationFrame(render)
      TWEEN.update()

      renderer.render(scene, camera)
    }

    function onWindowResize() {
      var innerWidth = window.innerWidth
      var innerHeight = window.innerHeight
      camera.aspect = innerWidth / innerHeight
      camera.updateProjectionMatrix()
      camera.updateProjectionMatrix()
      renderer.setSize(window.innerWidth, window.innerHeight)
    }

  </script>
</body>

</html>
