<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <script src="/static/three/three.min.js"></script>
  <script src="/static/three/SVGLoader.js"></script>
  <script src="/static/three/OrbitControls.js"></script>
  <style>
    html, body{
      margin: 0;
      padding: 0;
      color: rgb(86, 191, 248)
    }
  </style>
</head>

<body>
  <div id="WebGL-output"></div>
  <div id="slide" style="position: absolute;top: 0;">
    <a href="javascript:;" onclick="upTrigger()">上升</a>
    <a href="javascript:;" onclick="downTrigger()">下降</a>
  </div>

  <script type="text/javascript">
    var renderer, scene, camera, group;
    var scale = 1; // 缩放比
    var floorHeight = 140;
    var planeList = []; // 面网格集合
    var geometryArr = []; // 物体集合
    var materialArr = []; // 材质=集合
    var clock = new THREE.Clock(); // 动画clock
    var pointCloudArr = []; // 单个粒子网格集合
    var mixArr = [], pointArr = new Array(1000) // 粒子集合

    // 将第一层在数组中的索引值作为参考count
    // 临界点：
    // 最小count: 参考数-(地下层数-1)
    // 最大count：参考数+(地上层数-5)
    var floorCount // 楼层
    var count // 动态参考值
    var standardCount // 固定参考值
    var positionSpeed = 2 // 位移运动速度
    var opacitySpeed = 0.5 * positionSpeed / floorHeight // 透明度运动速度
    var opacitySpeed2 = 1 * positionSpeed / floorHeight // 商店透明度运动参数
    var opacitySpeed3 = 0.6 * positionSpeed / floorHeight // 边缘透明度运动参数
    var upClick = false // 上升trigger变量
    var upHeight = 0 // 上升起始高度
    var downClick = false // 下降trigger变量
    var downHeight = floorHeight // 下降起始高度
    
    var floorArr; // 接收楼层信息
    // 模拟数据
    var floorArrMock = [
      {
        coordinate_y: -3 * floorHeight - floorHeight,
        img_url: 1,
        floor: '-3'
      },
      {
        coordinate_y: -2 * floorHeight - floorHeight,
        img_url: 2,
        floor: '-2'
      },
      {
        coordinate_y: -1 * floorHeight - floorHeight,
        img_url: 3,
        floor: '-1'
      },
      {
        coordinate_y: 1 * floorHeight - floorHeight * 2,
        img_url: 4,
        floor: '1'
      },
      {
        coordinate_y: 2 * floorHeight - floorHeight * 2,
        img_url: 5,
        floor: '2'
      },
      {
        coordinate_y: 3 * floorHeight - floorHeight * 2,
        img_url: 6,
        floor: '3'
      },
      {
        coordinate_y: 4 * floorHeight - floorHeight * 2,
        img_url: 7,
        floor: '4'
      },
      {
        coordinate_y: 5 * floorHeight - floorHeight * 2,
        img_url: 8,
        floor: '5'
      },
      {
        coordinate_y: 6 * floorHeight - floorHeight * 2,
        img_url: 9,
        floor: '6'
      },
      {
        coordinate_y: 7 * floorHeight - floorHeight * 2,
        img_url: 10,
        floor: '7'
      }
    ]

    function init() {
      renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true
      })
      renderer.setSize(window.innerWidth, window.innerHeight)
      renderer.setClearColor('#ffffff', 1.0)

      scene = new THREE.Scene();
      scene.background = new THREE.Color('#17151a')

      // camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 10000)
      // camera.position.set(762, 399, 1170)

      camera = new THREE.OrthographicCamera(
        window.innerWidth / - 2,
        window.innerWidth / 2,
        window.innerHeight / 2,
        window.innerHeight / - 2,
        0.1, 10000
      )
      camera.position.set(330, 180, 450)
      camera.lookAt(0, 0, 0)
      scene.add(camera)

      var light = new THREE.PointLight('#ffffff', 0.8)
      camera.add(light)

      // var axesHelper = new THREE.AxesHelper(100)
      // scene.add(axesHelper)

      group = new THREE.Group()
      group.position.set(-290 * scale, -80, -241 * scale)
      // group.rotation.set(-0.05*Math.PI, 0, 0)
      scene.add(group)

      document.getElementById("WebGL-output").appendChild(renderer.domElement)
      window.addEventListener('resize', onWindowResize, false)
      window.addEventListener('mousemove', onDocumentMouseMove, false)
      window.addEventListener('mousedown', onDocumentMouseClick, false)

      addControl()
      loadSignal()

    }

    init()
    render()

    // 计算上升和下降的变化
    function getUpDownFloorCount() {
      var downFloorCount = 0
      var upFloorCount = 0
      var position = 0
      // console.log(floorArr)
      floorArr.forEach((item, index) => {
        if (item.floor < 0) {
          downFloorCount += 1
        } else {
          if (item.floor === 1) position = index
          upFloorCount += 1
        }
      })
      return {
        position: position,
        down: downFloorCount,
        up: upFloorCount
      }
    }

    // 计算参考点的位置
    function setSlideInfo() {
      floorCount = getUpDownFloorCount()
      count = floorCount.position // 动态基准数
      // console.log(count)
      standardCount = floorCount.position // 固定基准数
      floorCount.down = standardCount - (floorCount.down - 1)
      floorCount.up = standardCount + (floorCount.up - 5)
      minFloor = caculateMinusIndex(floorArr)
    }

    function upTrigger() {
      if (count > floorCount.down - 1 && upClick === false && downClick === false)
        upClick = true
    }

    function downTrigger() {
      if (count < floorCount.up + 1 && downClick === false && upClick === false)
        downClick = true
    }

    function upFloor() {
      upHeight += positionSpeed
      group.position.y += positionSpeed
      group.children[count - 1].children.forEach(item => {
        if (item.name === 'plane') {
          item.material.opacity += opacitySpeed
        } else {
          item.material.opacity += opacitySpeed2
        }
      })
      group.children[count + 3].children.forEach(item => {
        if (item.name === 'plane') {
          item.material.opacity -= opacitySpeed
        } else {
          item.material.opacity -= opacitySpeed2
        }
      })
      if (upHeight >= floorHeight) {
        upClick = false
        upHeight = 0
        count--
      }
    }

    function downFloor() {
      downHeight -= positionSpeed
      group.position.y -= positionSpeed
      group.children[count].children.forEach(item => {
        if (item.name === 'plane') {
          item.material.opacity -= opacitySpeed
        } else {
          item.material.opacity -= opacitySpeed2
        }
      })
      group.children[count + 4].children.forEach(item => {
        if (item.name === 'plane') {
          item.material.opacity += opacitySpeed
        } else {
          item.material.opacity += opacitySpeed2
        }
      })
      if (downHeight <= 0) {
        downClick = false
        downHeight = floorHeight
        count++
      }
    }

    // 闪光粒子map
    function ShineCanvas() {
      var canvas = document.createElement('canvas');
      canvas.width = 32;
      canvas.height = 32;
      var context = canvas.getContext('2d');
      var gradient = context.createRadialGradient(
        canvas.width / 2,
        canvas.height / 2,
        0,
        canvas.width / 2,
        canvas.height / 2,
        canvas.width / 2
      );
      gradient.addColorStop(0, 'rgba(255, 255, 255, 1');
      gradient.addColorStop(0.2, 'rgba(255,255,255,1)');
      gradient.addColorStop(0.4, 'rgba(157,159,13,1)');
      gradient.addColorStop(0.7, 'rgba(0,0,0,1)');
      context.fillStyle = gradient;
      context.fillRect(0, 0, canvas.width, canvas.height);
      this.texture = new THREE.Texture(canvas);
      this.texture.needsUpdate = true;
    }

    // 闪光粒子mesh
    function Shine(i, alex, floor) {
      if (i < 100) {
        geometryArr[i] = new THREE.CircleGeometry(10, 50, 32)
        materialArr[i] = new THREE.MeshBasicMaterial({
          color: new THREE.Color('#fcff15'),
          transparent: true,
          side: THREE.DoubleSide,
          blending: THREE.AdditiveBlending,
          map: new ShineCanvas().texture
        })
        pointArr[i] = new THREE.Mesh(
          geometryArr[i],
          materialArr[i]
        )
        pointArr[i].sortParticles = true;
        pointArr[i].position.set(alex[0], floor, alex[1])
        pointArr[i].rotation.x = 0.5 * Math.PI
        scene.add(pointArr[i])
      } else {
        i = i % 100;
        pointArr[i].position.set(alex[0], floor, alex[1])
        pointArr[i].rotation.x = 0.5 * Math.PI
      }
      if (floor < -floorHeight || floor > 2 * floorHeight + 5) {
        pointArr[i].visible = false
      } else {
        pointArr[i].visible = true
      }
      return pointArr[i]
    }

    // 闪光粒子animate
    function createAnimate(knot, index) {
      var scaleKF = new THREE.VectorKeyframeTrack(
        '.scale',
        [0, 0.25, 0.4, 0.7],
        [0, 0, 0, 1.4, 1.4, 1.4, 1, 1, 1, 0, 0, 0]
      );
      var opacityKF = new THREE.NumberKeyframeTrack(
        '.material.opacity',
        [0, 0.25, 0.4, 0.7],
        [0.3, 0.4, 1, 0]
      );
      var clip = new THREE.AnimationClip(
        'Action',
        0.7,
        [scaleKF, opacityKF]
      );
      var mixer = new THREE.AnimationMixer(knot);
      var clipAction = mixer.clipAction(clip);
      mixArr[index] = mixer
      clipAction.play();
      clipAction.loop = THREE.LoopOnce
    }

    var shine;

    // 创建闪点
    function createShine(alx, floor) {
      alx = alx.replace('[', '')
      alx = alx.replace(']', '')
      alx = alx.split(',')
      pointCloudArr.push(alx)
      var index = pointCloudArr.length - 1
      // var floor = 1
      var alpha = 1
      if(floor > 0) {
        alpha = 2
      } else {
        alpha = 1
      }
      floor = 8 + floor * floorHeight - (count - standardCount) * floorHeight - (10 - 1) * 140 - alpha * floorHeight - 80
      shine = Shine(index, alx, floor)
      createAnimate(shine, index)
    }

    function getRandom(n, m) {
      var n1 = Number(n); //强制转换成数字
      var m2 = Number(m);
      if (isNaN(n1) || isNaN(m2)) { //判断是否为有效数字 ，其中一个不是有效数字就返回[0,1)之间的随机小数
        return math.random();
      }
      if (n1 > m2) { //如果n>m则交换
        var temp = n1;
        n1 = m2;
        m2 = temp;
      }
      return Math.round(Math.random() * (m2 - n1) + n1);
    }

    function onDocumentMouseMove(event) {
      if (upClick === false && downClick === false) {
        var vector = new THREE.Vector3(
          (event.clientX / (window.innerWidth)) * 2 - 1,
          -(event.clientY / (window.innerHeight)) * 2 + 1,
          0.5
        );
        vector = vector.unproject(camera);
        var raycaster = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize());
        var rayPlaneList = planeList.slice(count, count+4)
        var subRayList = group.children.slice(count, count+4)
        var intersects = raycaster.intersectObjects(rayPlaneList);
        // if (intersects.length > 0) {
        //   for (var i = 0; i < rayPlaneList.length; i++) {
        //     if (intersects[0].object === rayPlaneList[i]) {
        //       moveChange(subRayList[i], 0x2a4586, 0xA1BCD4)
        //     } else {
        //       moveChange(subRayList[i], 0x233E85, 0xA1BCD4)
        //     }
        //   }
        // } else {
        //   for (var i = 0; i < rayPlaneList.length; i++) {
        //     moveChange(subRayList[i], 0x233E85, 0xA1BCD4)
        //   }
        // }
      }

    }

    function moveChange(objectList, meshColor, lineColor) {
      objectList.children.forEach(item => {
        if (item.type === 'Mesh') {
          item.material.color = new THREE.Color(meshColor)
        } else {
          item.material.color = new THREE.Color(lineColor)
        }
        item.material.opacity = 0.3
      })
    }

    function onDocumentMouseClick(event) {
      // 透视相机计算raycaster
      // var vector = new THREE.Vector3(
      //   (event.clientX / (window.innerWidth)) * 2 - 1,
      //   -(event.clientY / (window.innerHeight)) * 2 + 1,
      //   0.5
      // );
      // vector = vector.unproject(camera);
      // var raycaster = new THREE.Raycaster(
      //   camera.position,
      //   vector.sub(camera.position).normalize()
      // );

      // 正交相机计算raycaster
      var raycaster = new THREE.Raycaster(); // create once
      var mouse = new THREE.Vector2(); // create once
      mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
      mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;
      raycaster.setFromCamera( mouse, camera );

      var rayPlaneList = planeList.slice(count, count + 4)
      var intersects = raycaster.intersectObjects( rayPlaneList );
      if (intersects.length > 0) {
        window.parent.postMessage({
          cmd: 'change-floor',
          params: {
            data: intersects[0].object.position.y
          }
        }, '*');
      }
    }

    function loadSignal() {
      window.parent.postMessage({
        cmd: 'home-load_signal',
        params: {}
      }, '*');
    }

    // 接收楼层信息
    function setFloorInfo(floor) {
      if(floor.length > 1){
        if (floor[0].floor < floor[1].floor)
          floorArr = floor
        else
          floorArr = floor.reverse()
      }
      if (floor.length <= 4) {
        let slideBox = document.getElementById('slide')
        slideBox.style.display = 'none'
      }
      setSlideInfo()
      // 创建楼层图片
      for (var i = 0; i < floorArr.length; i++) {
        loadSvg(group, floorArr[i], i)
      }
    }

    // 添加Orbit控制器
    function addControl() {
      controls = new THREE.OrbitControls(camera);
      // controls.maxPolarAngle = 1.28;//上下两极的可视区域的最大角度
      // controls.minPolarAngle = 1.28;//上下两极的可视区域最小角度
      // controls.dampingFactor = 0.25;
      controls.enableZoom = true;
      controls.enableRotate = true;
      controls.screenSpacePanning = true;
    }

    function loadSvg(group, floorInfo, i) {
      var floorGroup = new THREE.Group()
      
      if (floorInfo.floor < 0) { floorGroup.name = 'B' + Math.abs(floorInfo.floor) }
      else { floorGroup.name = 'F' + Math.abs(floorInfo.floor) }
        
      addLineShape(floorInfo, floorGroup)
      addShape(floorInfo, floorGroup);

      // switch (i) {
      //   case count:
      //     floorGroup.rotation.x = -0.05 * Math.PI
      //     break;
      //   case count+1:
      //     floorGroup.rotation.x = 0.01 * Math.PI
      //     break;
      //   case count+2:
      //     floorGroup.rotation.x = 0.03 * Math.PI
      //     break;
      //   case count+3:
      //     floorGroup.rotation.x = 0.025 * Math.PI
      //     break;
      // }

      group.add(floorGroup)
    }

    var minFloor;
    function caculateMinusIndex(arr) {
      let minFloor = 1000
      for (let i = 0; i < arr.length; i++) {
        if (arr[i].floor < minFloor && arr[i].floor > 0) {
          minFloor = arr[i].floor;
        }
      }
      return minFloor
    }

    // 初始的四层 旋转不同角度
    // 上升：第四层回到正常角度 3到-1按次旋转
    // 下降：第一层回到正常角度 4到2按次序旋转

    function addLineShape(info, group) {
      var loader = new THREE.SVGLoader()
      // console.log('floor ----------', info)
      if (!info.img_url) {
        console.error('map url is not exist')
        return
      }
      loader.load(info.img_url, paths => {
        for (var i = 0; i < paths.length; i++) {
          var path = paths[i]
          var depth = 7
          var shapes = path.toShapes(true);
          var opacity = info.coordinate_y < -floorHeight || info.coordinate_y > floorHeight * 2 ? 0 : 0.9
          for (var j = 0; j < shapes.length; j++) {
            var shape = shapes[j];
            if (i !== 0) {
              shape.autoClose = true
              var points = shape.getPoints()
              // var geometryPoints = new THREE.BufferGeometry().setFromPoints(points)
              // var materialPoints = new THREE.LineBasicMaterial({
              //   color: '#A1BCD4',
              //   transparent: true,
              //   opacity: opacity
              // })
              // var line = new THREE.Line(geometryPoints, materialPoints)
              // line.position.set(0, info.coordinate_y, 0)
              // line.rotation.set(0.5 * Math.PI, 0, 0)
              // line.add(edgeLine)
              // group.add(line)

              var geometry = new THREE.ExtrudeBufferGeometry(shape, {depth: depth, bevelEnabled: false})
              
              var geometry2 = new THREE.Geometry();
              geometry2.fromBufferGeometry(geometry)
              
              var materialLine = new THREE.MeshBasicMaterial({
                color: new THREE.Color('#5F719E'),
                transparent: true,
                opacity: opacity,
                side: THREE.DoubleSide,
                vertexColors: THREE.FaceColors
                // depthWrite: false
              })
              var line = new THREE.Mesh(geometry2, materialLine)
              line.geometry.faces.forEach(face => {
                if (face.normal.y !== 0) {
                  face.color = new THREE.Color('#0E1239')
                }
                
              })
             
              var edgeGeometry = new THREE.BufferGeometry().setFromPoints(points)
              var edgeMaterial = new THREE.LineBasicMaterial({
                color: '#2A4586',
                transparent: true,
                opacity: opacity
              })
              var edges = new THREE.Line(edgeGeometry, edgeMaterial)

              // var edges = new THREE.EdgesGeometry(geometry)
              // var edgeLine = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({color: '#000000'}))
              
              line.position.set(0, info.coordinate_y + depth, 0)
              line.rotation.set(0.5 * Math.PI, 0, 0)
              line.name = 'store'
              edges.position.set(0, info.coordinate_y + depth, 0)
              edges.rotation.set(0.5 * Math.PI, 0, 0)
              edges.name = 'edges'
              group.add(edges)
              group.add(line)
            }
          }
        }
      })
    }

    function addShape(info, group) {
      var loader = new THREE.SVGLoader()
      loader.load('/static/origin-floor/bottom.svg', paths => {
        for (var i = 0; i < paths.length; i++) {
          var path = paths[i]
          var shapes = path.toShapes(true);
          for (var j = 0; j < shapes.length; j++) {
            var shape = shapes[j];
            var geometry = new THREE.ShapeBufferGeometry(shape);
            var mesh = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({
              color: '#2A4586',
              side: THREE.DoubleSide,
              transparent: true,
              opacity: info.coordinate_y < -floorHeight || info.coordinate_y > floorHeight * 2 ? 0 : 0.5
            }));

            mesh.position.set(0, info.coordinate_y, 0);
            mesh.rotation.set(0.5 * Math.PI, 0, 0);
            mesh.name = 'plane'
            planeList.push(mesh);
            group.add(mesh);
          }
        }
      })
    }

    function render() {
      requestAnimationFrame(render)

      // var alex = '[' + getRandom(-80, 80) + ',' + getRandom(-50, 50) + ']';
      // var floor = getRandom(-4, 5)
      // if ((count || count === 0) && upClick === false && downClick === false) {

      //   createShine(alex, floor * floorHeight - (count - standardCount) * floorHeight)
      // }

      var delta = clock.getDelta()
      for (var i = 0; i < mixArr.length; i++) {
        mixArr[i].update(delta)
      }

      if (upClick === true) upFloor()
      if (downClick === true) downFloor()
      renderer.render(scene, camera)
    }

    function onWindowResize() {
      camera.left = window.innerWidth / -2;
      camera.right = window.innerWidth / 2;
      camera.top = window.innerHeight / 2;
      camera.bottom = window.innerHeight / -2;
      camera.updateProjectionMatrix()
      renderer.setSize(window.innerWidth, window.innerHeight)
    }

  </script>
</body>

</html>
