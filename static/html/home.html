<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>OrbitControls</title>
  <script src="/static/three/three.min.js"></script>
  <script src="/static/three/OrbitControls.js"></script>
  <script src="/static/three/SVGLoader.js"></script>
  <style>
    html, body{
      margin: 0;
      padding: 0;
    }
  </style>
</head>
<body>
<div id="WebGL-output"></div>
<div style="position: absolute;top: 0;">
  <a href="javascript:;" onclick="upFloor()">上一层</a>
  <a href="javascript:;" onclick="downFloor()">下一层</a>
</div>
<script type="text/javascript">
  let renderer, scene, camera, group;
  let scale = 0.6; // 缩放比
  let clock = new THREE.Clock();
  let mixArr = [], pointArr = new Array(1000)
  let meshList = [];
  let planeList = [];
  let geometryArr = [];
  let materialArr = [];
  let pointCloudArr = [];
  let floorHeight = 65;
  let floorArr = [
    0 * floorHeight, 
    1 * floorHeight, 
    2 * floorHeight, 
    3 * floorHeight, 
    4 * floorHeight, 
    5 * floorHeight, 
    6 * floorHeight, 
    7 * floorHeight, 
    8 * floorHeight, 
    9 * floorHeight
  ]
  function init() {
    renderer = new THREE.WebGLRenderer({antialias: true, alpha: true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor('#ffffff', 1.0);

    scene = new THREE.Scene();
    scene.background = new THREE.Color('#232027');

    camera = new THREE.PerspectiveCamera(45, (window.innerWidth) / (window.innerHeight), 0.1, 10000 );
    camera.position.set( 260, 200, 350 );
    camera.lookAt(0, 65, 0)
    scene.add(camera);

    let light = new THREE.PointLight( 0xffffff, 0.8 );
    camera.add(light);

    // let axesHelper = new THREE.AxesHelper( 10 );
    // scene.add(axesHelper);

    group = new THREE.Group();
    group.position.set(-290*scale, 0, -241*scale)
    scene.add(group);

    document.getElementById("WebGL-output").appendChild(renderer.domElement);
    window.addEventListener('resize', onWindowResize, false);
    window.addEventListener('mousemove', onDocumentMouseMove, false)
    window.addEventListener('click', onDocumentMouseClick, false)

    addControl();
    loadSignal();

  }

  function upFloor() {
    let height = 0
    let timer = setInterval(function(){
      group.position.y += 1
      height += 1
      // group.matrixAutoUpdate  = false;
      // group.updateMatrix();
      if(height >= 65){
        clearInterval(timer)
      }
    }, 10)
  }

  function downFloor() {
    let height = 65
    let timer = setInterval(function(){
      group.position.y -= 1
      height -= 1
      if(height<=0){
        clearInterval(timer)
      }
    }, 10)
  }

  function loadSignal () {
    window.parent.postMessage({
      cmd: 'home-load_signal',
      params: {}
    }, '*');
  }

  function onWindowResize () {
    camera.aspect = (window.innerWidth) / (window.innerHeight)
    camera.updateProjectionMatrix()
    renderer.setSize(window.innerWidth, window.innerHeight)
  }

  function onDocumentMouseClick(event) {
    let vector = new THREE.Vector3((event.clientX / (window.innerWidth)) * 2 - 1, -( event.clientY / (window.innerHeight) ) * 2 + 1, 0.5);
    vector = vector.unproject(camera);
    let raycaster = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize());
    let intersects = raycaster.intersectObjects(planeList);
    if (intersects.length > 0) {
      window.parent.postMessage({
        cmd: 'change-floor',
        params: {
          data: intersects[0].object.position.y
        }
      }, '*');
    }
  }

  function onDocumentMouseMove (event) {
    let vector = new THREE.Vector3(( event.clientX / (window.innerWidth) ) * 2 - 1, -( event.clientY / (window.innerHeight) ) * 2 + 1, 0.5);
    vector = vector.unproject(camera);
    let raycaster = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize());
    let intersects = raycaster.intersectObjects(planeList);
    if (intersects.length > 0) {
      for (let i = 0; i < planeList.length; i++) {
        if (intersects[0].object === planeList[i]) {
          planeList[i].material.color = new THREE.Color('#162b68')
          planeList[i].material.opacity = 0.7
        } else {
          planeList[i].material.color = new THREE.Color('#091331')
          if (planeList[i].position.y<-65) {
            planeList[i].material.opacity = 0
          }
          planeList[i].material.side = THREE.DoubleSide
        }
      }
    }else{
      for (let i = 0; i < planeList.length; i++) {
        planeList[i].material.color = new THREE.Color('#091331')
        if (planeList[i].position.y<-65) {
            planeList[i].material.opacity = 0
          }
        planeList[i].material.side = THREE.DoubleSide
      }
    }
  }

  // 接收楼层信息
  function setFloorInfo() {
    // 创建楼层图片
    console.log(floorArr);
    for (let i=0; i<floorArr.length; i++) {
      loadSvg(group, floorArr[i], parseInt(floorArr[i]/65+1))
    }
  }

  // 添加Orbit控制器
  function addControl() {
    controls = new THREE.OrbitControls(camera);
    controls.dampingFactor = 0.25;
    controls.enableZoom = true;
    controls.enableRotate = false;
    controls.screenSpacePanning = false;
  }

  // 加载SVG图片
  function loadSvg (group, positionY, image) {
    let svgLoader = new THREE.SVGLoader()
    svgLoader.load('/static/origin-floor/' + image + '.svg', (paths) => {
      for ( let i = 0; i < paths.length; i ++ ) {
        let path = paths[i];
        let shapes = path.toShapes(true);
        for (let j = 0; j < shapes.length; j++) {
          let shape = shapes[j];
          if (i === 0) {
            addShape(shape, group, '#091331', positionY);
          } else {
            addLineShape(shape, group, 'rgb(59, 180, 243)', positionY);
          }
        }
      }
    })
  }
  
  function addShape(shape, group, color, y) {
    let geometry = new THREE.ShapeBufferGeometry( shape );
    let mesh = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({ 
      color: color, 
      side: THREE.DoubleSide, 
      transparent: true, 
      opacity: y<-65 ? 0 : 0.5 
    }));
    mesh.position.set(0, y, 0);
    mesh.rotation.set(0.5*Math.PI, 0, 0);
    mesh.scale.set(scale, scale, scale);
    planeList.push(mesh);
    group.add(mesh);
  }

  // 绘制单层平面图
  function addLineShape( shape, group, color, y) {
    shape.autoClose = true;
    let points = shape.getPoints();
    let geometryPoints = new THREE.BufferGeometry().setFromPoints( points );

    let line = new THREE.Line(geometryPoints, new THREE.LineBasicMaterial({ 
      color: color, 
      transparent: true, 
      opacity: y<-65 ? 0 : 0.5 
    }));
    line.position.set(0, y, 0);
    line.rotation.set(0.5*Math.PI, 0, 0);
    line.scale.set(scale, scale, scale);
    meshList.push(line)
    group.add(line);
  }

  // 创建闪光粒子canvas
  function generateSprite() {
    let canvas = document.createElement('canvas');
    canvas.width = 16;
    canvas.height = 16;

    let context = canvas.getContext('2d');
    let gradient = context.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
    gradient.addColorStop(0, 'rgba(255,255,255,1)');
    gradient.addColorStop(0.2, 'rgba(255,255,255,1)');
    gradient.addColorStop(0.4, 'rgba(157,159,13,1)');
    gradient.addColorStop(0.7, 'rgba(0,0,0,1)');

    context.fillStyle = gradient;
    context.fillRect(0, 0, canvas.width, canvas.height);

    let texture = new THREE.Texture(canvas);
    texture.needsUpdate = true;
    return texture;
  }

  // 创建闪光粒子: 接收从父页面中传递进来的值
  function createPointCloud(alx, floor) {
    alx = alx.replace('[', '')
    alx = alx.replace(']', '')
    alx = alx.split(',')
    pointCloudArr.push(alx)
    let icount = pointCloudArr.length - 1
    console.log(icount)

    if (pointCloudArr.length<100) {
      geometryArr[icount] = new THREE.CircleGeometry(4, 50, 32)
      materialArr[icount] = new THREE.MeshBasicMaterial({
        color: new THREE.Color('#fcff15'),
        transparent: true,
        side: THREE.DoubleSide,
        blending: THREE.AdditiveBlending,
        map: generateSprite()
      });
      pointArr[icount] = new THREE.Mesh(geometryArr[icount], materialArr[icount]);
      pointArr[icount].sortParticles = true;
      pointArr[icount].position.set(alx[0], (floor-1)*65+1, alx[1])
      pointArr[icount].rotation.x = 0.5*Math.PI
      scene.add(pointArr[icount]);
      createAnimate(pointArr[icount], icount)
    } else {
      icount = icount%100
      pointArr[icount].position.set(alx[0], (floor-1)*65+1, alx[1])
      pointArr[icount].rotation.x = 0.5*Math.PI
      createAnimate(pointArr[icount], icount)
    }
  }

  // 获取随机数方法
  function getRandom(n,m){
    let n1 = Number(n); //强制转换成数字
    let m2 = Number(m);
    if(isNaN(n1) || isNaN(m2)){ //判断是否为有效数字 ，其中一个不是有效数字就返回[0,1)之间的随机小数
      return math.random();
    }
    if(n1 > m2){ //如果n>m则交换
      let temp=n1;
      n1 = m2;
      m2 = temp;
    }
    return Math.round(Math.random()*(m2-n1)+n1);

  }

  // 创建闪烁动画
  function createAnimate (knot, i) {
    let scaleKF = new THREE.VectorKeyframeTrack( '.scale', [ 0, 0.15, 0.3, 0.5 ], [ 0, 0, 0, 1.4, 1.4, 1.4, 1, 1, 1, 0, 0, 0 ] );
    let opacityKF = new THREE.NumberKeyframeTrack( '.material.opacity', [ 0, 0.15, 0.3, 0.5 ], [ 0.3, 0.4, 1, 0 ] );
    let clip = new THREE.AnimationClip( 'Action', 0.5, [ scaleKF, opacityKF ] );
    let mixer = new THREE.AnimationMixer( knot );
    let clipAction = mixer.clipAction( clip );
    mixArr[i] = mixer
    clipAction.play();
    // clipAction.loop = THREE.LoopOnce
  }

  function render() {
    requestAnimationFrame( render );
    let delta = clock.getDelta();
    for (let i = 0; i < mixArr.length; i++) {
      mixArr[i].update( delta );
    }
    renderer.render(scene, camera)
  }

  function dispose(o) {
    try {
      if (o && typeof o === 'object') {
        if (Array.isArray(o)) {
          o.forEach(dispose);
        } else
        if (o instanceof THREE.Object3D) {
          dispose(o.geometry);
          dispose(o.material);
          if (o.parent) {
            o.parent.remove(o);
          }
          dispose(o.children);
        } else
        if (o instanceof THREE.Geometry) {
          o.dispose();
        } else
        if (o instanceof THREE.Material) {
          o.dispose();
          dispose(o.materials);
          dispose(o.map);
          dispose(o.lightMap);
          dispose(o.bumpMap);
          dispose(o.normalMap);
          dispose(o.specularMap);
          dispose(o.envMap);
        } else
        if (typeof o.dispose === 'function') {
          o.dispose();
        } else {
          Object.values(o).forEach(dispose);
        }
      }
    } catch (error) {
      console.log(error);
    }
  }

  ///////////////////
  ////// 传值 ///////
  //////////////////

  init()
  render()
</script>
</body>
</html>
